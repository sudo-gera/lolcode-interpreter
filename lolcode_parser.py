#!/usr/bin/env python3.8
# @generated by pegen from lolcode.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[ast . Module]:
        # start: void* begin (statement)* end void* "$"
        mark = self._mark()
        if (
            (self._loop0_1(),)
            and
            (b := self.begin())
            and
            (a := self._loop0_2(),)
            and
            (self.end())
            and
            (self._loop0_3(),)
            and
            (self.expect("$"))
        ):
            return ast . Module ( token = b , body = [q for q in a if q is not ...] , type_ignores = [] , );
        self._reset(mark)
        return None;

    @memoize
    def new_line(self) -> Optional[Any]:
        # new_line: "\n" | "," | "$"
        mark = self._mark()
        if (
            (literal := self.expect("\n"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect(","))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("$"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def space(self) -> Optional[Any]:
        # space: " " | "\t"
        mark = self._mark()
        if (
            (literal := self.expect(" "))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("\t"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def join_one(self) -> Optional[Any]:
        # join_one: space | r"\.\.\." new_line | "…" new_line
        mark = self._mark()
        if (
            (space := self.space())
        ):
            return space;
        self._reset(mark)
        if (
            (literal := self.expect(r"\.\.\."))
            and
            (new_line := self.new_line())
        ):
            return [literal, new_line];
        self._reset(mark)
        if (
            (literal := self.expect("…"))
            and
            (new_line := self.new_line())
        ):
            return [literal, new_line];
        self._reset(mark)
        return None;

    @memoize
    def join(self) -> Optional[Any]:
        # join: join_one*
        # nullable=True
        mark = self._mark()
        if (
            (self._loop0_4(),)
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def join_stmt(self) -> Optional[Any]:
        # join_stmt: join_one+
        mark = self._mark()
        if (
            (self._loop1_5())
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def new_line_stmt(self) -> Optional[Any]:
        # new_line_stmt: "\n" | ","
        mark = self._mark()
        if (
            (self.expect("\n"))
        ):
            return ...;
        self._reset(mark)
        if (
            (self.expect(","))
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def void(self) -> Optional[Any]:
        # void: long_comment | comment | join_stmt | new_line_stmt
        mark = self._mark()
        if (
            (long_comment := self.long_comment())
        ):
            return long_comment;
        self._reset(mark)
        if (
            (comment := self.comment())
        ):
            return comment;
        self._reset(mark)
        if (
            (join_stmt := self.join_stmt())
        ):
            return join_stmt;
        self._reset(mark)
        if (
            (new_line_stmt := self.new_line_stmt())
        ):
            return new_line_stmt;
        self._reset(mark)
        return None;

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: long_comment | comment | expr_stmt | join_stmt | declare | assign | func | found | gtfo | branch | switch | loop | new_line_stmt | visible | gimmeh | cast
        mark = self._mark()
        if (
            (long_comment := self.long_comment())
        ):
            return long_comment;
        self._reset(mark)
        if (
            (comment := self.comment())
        ):
            return comment;
        self._reset(mark)
        if (
            (expr_stmt := self.expr_stmt())
        ):
            return expr_stmt;
        self._reset(mark)
        if (
            (join_stmt := self.join_stmt())
        ):
            return join_stmt;
        self._reset(mark)
        if (
            (declare := self.declare())
        ):
            return declare;
        self._reset(mark)
        if (
            (assign := self.assign())
        ):
            return assign;
        self._reset(mark)
        if (
            (func := self.func())
        ):
            return func;
        self._reset(mark)
        if (
            (found := self.found())
        ):
            return found;
        self._reset(mark)
        if (
            (gtfo := self.gtfo())
        ):
            return gtfo;
        self._reset(mark)
        if (
            (branch := self.branch())
        ):
            return branch;
        self._reset(mark)
        if (
            (switch := self.switch())
        ):
            return switch;
        self._reset(mark)
        if (
            (loop := self.loop())
        ):
            return loop;
        self._reset(mark)
        if (
            (new_line_stmt := self.new_line_stmt())
        ):
            return new_line_stmt;
        self._reset(mark)
        if (
            (visible := self.visible())
        ):
            return visible;
        self._reset(mark)
        if (
            (gimmeh := self.gimmeh())
        ):
            return gimmeh;
        self._reset(mark)
        if (
            (cast := self.cast())
        ):
            return cast;
        self._reset(mark)
        return None;

    @memoize
    def expr_stmt(self) -> Optional[Any]:
        # expr_stmt: end_expr new_line
        mark = self._mark()
        if (
            (a := self.end_expr())
            and
            (self.new_line())
        ):
            return ast . Assign ( token = a . token , targets = [ast . Name ( token = a . token , id = "IT" , )] , value = a , lineno = 0 , );
        self._reset(mark)
        return None;

    @memoize
    def end_expr(self) -> Optional[Any]:
        # end_expr: mid_expr | hard_end_bin_op | soft_end_bin_op | soft_end_var_op | end_call | end_un_op
        mark = self._mark()
        if (
            (mid_expr := self.mid_expr())
        ):
            return mid_expr;
        self._reset(mark)
        if (
            (hard_end_bin_op := self.hard_end_bin_op())
        ):
            return hard_end_bin_op;
        self._reset(mark)
        if (
            (soft_end_bin_op := self.soft_end_bin_op())
        ):
            return soft_end_bin_op;
        self._reset(mark)
        if (
            (soft_end_var_op := self.soft_end_var_op())
        ):
            return soft_end_var_op;
        self._reset(mark)
        if (
            (end_call := self.end_call())
        ):
            return end_call;
        self._reset(mark)
        if (
            (end_un_op := self.end_un_op())
        ):
            return end_un_op;
        self._reset(mark)
        return None;

    @memoize
    def mid_expr(self) -> Optional[Any]:
        # mid_expr: hard_mid_bin_op | soft_mid_bin_op | soft_mid_var_op | constant | var_name | mid_call | mid_un_op | make
        mark = self._mark()
        if (
            (hard_mid_bin_op := self.hard_mid_bin_op())
        ):
            return hard_mid_bin_op;
        self._reset(mark)
        if (
            (soft_mid_bin_op := self.soft_mid_bin_op())
        ):
            return soft_mid_bin_op;
        self._reset(mark)
        if (
            (soft_mid_var_op := self.soft_mid_var_op())
        ):
            return soft_mid_var_op;
        self._reset(mark)
        if (
            (constant := self.constant())
        ):
            return constant;
        self._reset(mark)
        if (
            (var_name := self.var_name())
        ):
            return var_name;
        self._reset(mark)
        if (
            (mid_call := self.mid_call())
        ):
            return mid_call;
        self._reset(mark)
        if (
            (mid_un_op := self.mid_un_op())
        ):
            return mid_un_op;
        self._reset(mark)
        if (
            (make := self.make())
        ):
            return make;
        self._reset(mark)
        return None;

    @memoize
    def soft_end_arg_list(self) -> Optional[Any]:
        # soft_end_arg_list: mid_expr ["AN" join] soft_end_arg_list | end_expr ["MKAY" join]
        mark = self._mark()
        if (
            (a := self.mid_expr())
            and
            (self._tmp_6(),)
            and
            (b := self.soft_end_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (a := self.end_expr())
            and
            (self._tmp_7(),)
        ):
            return [a];
        self._reset(mark)
        return None;

    @memoize
    def hard_end_arg_list(self) -> Optional[Any]:
        # hard_end_arg_list: mid_expr "AN" join hard_end_arg_list | end_expr ["MKAY" join]
        mark = self._mark()
        if (
            (a := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (b := self.hard_end_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (a := self.end_expr())
            and
            (self._tmp_8(),)
        ):
            return [a];
        self._reset(mark)
        return None;

    @memoize
    def func_end_arg_list(self) -> Optional[Any]:
        # func_end_arg_list: "YR" join mid_expr "AN" join func_end_arg_list | "YR" join end_expr ["MKAY" join] | ["MKAY" join]
        # nullable=True
        mark = self._mark()
        if (
            (self.expect("YR"))
            and
            (self.join())
            and
            (a := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (b := self.func_end_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (self.expect("YR"))
            and
            (self.join())
            and
            (a := self.end_expr())
            and
            (self._tmp_9(),)
        ):
            return [a];
        self._reset(mark)
        if (
            (self._tmp_10(),)
        ):
            return [...];
        self._reset(mark)
        return None;

    @memoize
    def soft_mid_arg_list(self) -> Optional[Any]:
        # soft_mid_arg_list: mid_expr ["AN" join] soft_mid_arg_list | end_expr "MKAY" join
        mark = self._mark()
        if (
            (a := self.mid_expr())
            and
            (self._tmp_11(),)
            and
            (b := self.soft_mid_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (a := self.end_expr())
            and
            (self.expect("MKAY"))
            and
            (self.join())
        ):
            return [a];
        self._reset(mark)
        return None;

    @memoize
    def hard_mid_arg_list(self) -> Optional[Any]:
        # hard_mid_arg_list: mid_expr "AN" join hard_mid_arg_list | end_expr "MKAY" join
        mark = self._mark()
        if (
            (a := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (b := self.hard_mid_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (a := self.end_expr())
            and
            (self.expect("MKAY"))
            and
            (self.join())
        ):
            return [a];
        self._reset(mark)
        return None;

    @memoize
    def func_mid_arg_list(self) -> Optional[Any]:
        # func_mid_arg_list: "YR" join mid_expr "AN" join func_mid_arg_list | "YR" join mid_expr "MKAY" join | "MKAY" join
        mark = self._mark()
        if (
            (self.expect("YR"))
            and
            (self.join())
            and
            (a := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (b := self.func_mid_arg_list())
        ):
            return [a] + b;
        self._reset(mark)
        if (
            (self.expect("YR"))
            and
            (self.join())
            and
            (a := self.mid_expr())
            and
            (self.expect("MKAY"))
            and
            (self.join())
        ):
            return [a];
        self._reset(mark)
        if (
            (self.expect("MKAY"))
            and
            (self.join())
        ):
            return [...];
        self._reset(mark)
        return None;

    @memoize
    def end_un_op(self) -> Optional[Any]:
        # end_un_op: un_op_lit end_expr
        mark = self._mark()
        if (
            (op := self.un_op_lit())
            and
            (operand := self.end_expr())
        ):
            return ast . UnaryOp ( token = op . token , op = op , operand = operand );
        self._reset(mark)
        return None;

    @memoize
    def mid_un_op(self) -> Optional[Any]:
        # mid_un_op: un_op_lit mid_expr
        mark = self._mark()
        if (
            (op := self.un_op_lit())
            and
            (operand := self.mid_expr())
        ):
            return ast . UnaryOp ( token = op . token , op = op , operand = operand );
        self._reset(mark)
        return None;

    @memoize
    def hard_end_bin_op(self) -> Optional[Any]:
        # hard_end_bin_op: hard_bin_op_lit mid_expr "AN" join end_expr
        mark = self._mark()
        if (
            (op := self.hard_bin_op_lit())
            and
            (left := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (right := self.end_expr())
        ):
            return ast . BinOp ( token = op . token , left = left , op = op , right = right );
        self._reset(mark)
        return None;

    @memoize
    def soft_end_bin_op(self) -> Optional[Any]:
        # soft_end_bin_op: soft_bin_op_lit mid_expr "AN"? join end_expr
        mark = self._mark()
        if (
            (op := self.soft_bin_op_lit())
            and
            (left := self.mid_expr())
            and
            (self.expect("AN"),)
            and
            (self.join())
            and
            (right := self.end_expr())
        ):
            return ast . BinOp ( token = op . token , left = left , op = op , right = right );
        self._reset(mark)
        return None;

    @memoize
    def hard_mid_bin_op(self) -> Optional[Any]:
        # hard_mid_bin_op: hard_bin_op_lit mid_expr "AN" join mid_expr
        mark = self._mark()
        if (
            (op := self.hard_bin_op_lit())
            and
            (left := self.mid_expr())
            and
            (self.expect("AN"))
            and
            (self.join())
            and
            (right := self.mid_expr())
        ):
            return ast . BinOp ( token = op . token , left = left , op = op , right = right );
        self._reset(mark)
        return None;

    @memoize
    def soft_mid_bin_op(self) -> Optional[Any]:
        # soft_mid_bin_op: soft_bin_op_lit mid_expr "AN"? join mid_expr
        mark = self._mark()
        if (
            (op := self.soft_bin_op_lit())
            and
            (left := self.mid_expr())
            and
            (self.expect("AN"),)
            and
            (self.join())
            and
            (right := self.mid_expr())
        ):
            return ast . BinOp ( token = op . token , left = left , op = op , right = right );
        self._reset(mark)
        return None;

    @memoize
    def soft_end_var_op(self) -> Optional[Any]:
        # soft_end_var_op: soft_var_op_lit soft_end_arg_list
        mark = self._mark()
        if (
            (op := self.soft_var_op_lit())
            and
            (args := self.soft_end_arg_list())
        ):
            return ast . Compare ( token = op . token , ops = [op] , comparators = args , left = ast . Constant ( value = None ) );
        self._reset(mark)
        return None;

    @memoize
    def soft_mid_var_op(self) -> Optional[Any]:
        # soft_mid_var_op: soft_var_op_lit soft_mid_arg_list
        mark = self._mark()
        if (
            (op := self.soft_var_op_lit())
            and
            (args := self.soft_mid_arg_list())
        ):
            return ast . Compare ( token = op . token , ops = [op] , comparators = args , left = ast . Constant ( value = None ) );
        self._reset(mark)
        return None;

    @memoize
    def hard_bin_op_lit(self) -> Optional[Any]:
        # hard_bin_op_lit: "SUM" join "OF" join | "DIFF" join "OF" join | "PRODUKT" join | "QUOSHUNT" join | "MOD" join "OF" join | "BIGGR" join | "SMALLR" join
        mark = self._mark()
        if (
            (token := self.expect("SUM"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . Add ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("DIFF"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . Sub ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("PRODUKT"))
            and
            (self.join())
        ):
            return ast . Mult ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("QUOSHUNT"))
            and
            (self.join())
        ):
            return ast . Div ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("MOD"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . Mod ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("BIGGR"))
            and
            (self.join())
        ):
            return ast . Gt ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("SMALLR"))
            and
            (self.join())
        ):
            return ast . Lt ( token = token );
        self._reset(mark)
        return None;

    @memoize
    def soft_bin_op_lit(self) -> Optional[Any]:
        # soft_bin_op_lit: "BOTH" join "OF" join | "EITHER" join "OF" join | "WON" join "OF" join | "BOTH" join "SAEM" join | "DIFFRINT" join
        mark = self._mark()
        if (
            (token := self.expect("BOTH"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . BitAnd ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("EITHER"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . BitOr ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("WON"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . BitXor ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("BOTH"))
            and
            (self.join())
            and
            (self.expect("SAEM"))
            and
            (self.join())
        ):
            return ast . Eq ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("DIFFRINT"))
            and
            (self.join())
        ):
            return ast . NotEq ( token = token );
        self._reset(mark)
        return None;

    @memoize
    def soft_var_op_lit(self) -> Optional[Any]:
        # soft_var_op_lit: "ALL" join "OF" join | "ANY" join "OF" join | "SMOOSH" join
        mark = self._mark()
        if (
            (token := self.expect("ALL"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . And ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("ANY"))
            and
            (self.join())
            and
            (self.expect("OF"))
            and
            (self.join())
        ):
            return ast . Or ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("SMOOSH"))
            and
            (self.join())
        ):
            return ast . JoinedStr ( token = token );
        self._reset(mark)
        return None;

    @memoize
    def un_op_lit(self) -> Optional[Any]:
        # un_op_lit: "UPPIN" join | "NERFIN" join
        mark = self._mark()
        if (
            (token := self.expect("UPPIN"))
            and
            (self.join())
        ):
            return ast . UAdd ( token = token );
        self._reset(mark)
        if (
            (token := self.expect("NERFIN"))
            and
            (self.join())
        ):
            return ast . USub ( token = token );
        self._reset(mark)
        return None;

    @memoize
    def constant(self) -> Optional[Any]:
        # constant: int | float | string | bool | none | type
        mark = self._mark()
        if (
            (int := self.int())
        ):
            return int;
        self._reset(mark)
        if (
            (float := self.float())
        ):
            return float;
        self._reset(mark)
        if (
            (string := self.string())
        ):
            return string;
        self._reset(mark)
        if (
            (bool := self.bool())
        ):
            return bool;
        self._reset(mark)
        if (
            (none := self.none())
        ):
            return none;
        self._reset(mark)
        if (
            (type := self.type())
        ):
            return type;
        self._reset(mark)
        return None;

    @memoize
    def int(self) -> Optional[Any]:
        # int: r"-?\d+" !r"\." join
        mark = self._mark()
        if (
            (a := self.expect(r"-?\d+"))
            and
            (self.negative_lookahead(self.expect, r"\."))
            and
            (self.join())
        ):
            return ast . Constant ( value = int ( + a ) , token = a );
        self._reset(mark)
        return None;

    @memoize
    def float(self) -> Optional[Any]:
        # float: (r"-?\d+\.\d*" | r"-?\.\d+") join
        mark = self._mark()
        if (
            (a := self._tmp_12())
            and
            (self.join())
        ):
            return ast . Constant ( value = float ( + a ) , token = a );
        self._reset(mark)
        return None;

    @memoize
    def bool(self) -> Optional[Any]:
        # bool: ("WIN" | "FAIL") join
        mark = self._mark()
        if (
            (a := self._tmp_13())
            and
            (self.join())
        ):
            return ast . Constant ( value = bool ( "FAIL WIN" . index ( + a ) ) , token = a );
        self._reset(mark)
        return None;

    @memoize
    def none(self) -> Optional[Any]:
        # none: "NOOB" join
        mark = self._mark()
        if (
            (a := self.expect("NOOB"))
            and
            (self.join())
        ):
            return ast . constant ( None , token = a );
        self._reset(mark)
        return None;

    @memoize
    def type(self) -> Optional[Any]:
        # type: ("NOOB" | "TROOF" | "NUMBR" | "NUMBAR" | "YARN" | "TYPE") join
        mark = self._mark()
        if (
            (a := self._tmp_14())
            and
            (self.join())
        ):
            return ast . Constant ( {'NOOB' : type ( None ) , 'TROOF' : bool , 'NUMBR' : int , 'NUMBAR' : float , 'YARN' : str , 'TYPE' : type ,} [+ a] , token = a );
        self._reset(mark)
        return None;

    @memoize
    def var_name(self) -> Optional[Any]:
        # var_name: r"\w+" join
        mark = self._mark()
        if (
            (a := self.expect(r"\w+"))
            and
            (self.join())
        ):
            return ast . Name ( id = + a , token = a ) if + a not in self . SOFT_KEYWORDS + self . KEYWORDS else None;
        self._reset(mark)
        return None;

    @memoize
    def string(self) -> Optional[Any]:
        # string: r'"' string_tail join
        mark = self._mark()
        if (
            (token := self.expect(r'"'))
            and
            (tail := self.string_tail())
            and
            (self.join())
        ):
            return ast . Compare ( left = ast . Constant ( None , token = token ) , ops = [ast . JoinedStr ( )] , comparators = [q for q in tail if q is not ...] );
        self._reset(mark)
        return None;

    @memoize
    def hex(self) -> Optional[Any]:
        # hex: '(\d|[A-Fa-f])+'
        mark = self._mark()
        if (
            (a := self.expect('(\d|[A-Fa-f])+'))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def unicode_name(self) -> Optional[Any]:
        # unicode_name: r'[^]]+'
        mark = self._mark()
        if (
            (a := self.expect(r'[^]]+'))
        ):
            return self . unicode_lookup ( + a );
        self._reset(mark)
        return None;

    @memoize
    def string_tail(self) -> Optional[Any]:
        # string_tail: r':\)' string_tail | r':>' string_tail | r':o' string_tail | r':"' string_tail | r'::' string_tail | '' '"' | r':\{' join end_expr '\}' string_tail | r':\(' join hex join '\)' string_tail | r':\[' join unicode_name join '\]' string_tail | r'.' string_tail
        mark = self._mark()
        if (
            (token := self.expect(r':\)'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = token , value = '\n' )] + tail;
        self._reset(mark)
        if (
            (token := self.expect(r':>'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = token , value = '\t' )] + tail;
        self._reset(mark)
        if (
            (token := self.expect(r':o'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = token , value = '\a' )] + tail;
        self._reset(mark)
        if (
            (token := self.expect(r':"'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = token , value = '"' )] + tail;
        self._reset(mark)
        if (
            (token := self.expect(r'::'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = token , value = ':' )] + tail;
        self._reset(mark)
        if (
            (self.expect(''))
            and
            (self.expect('"'))
        ):
            return [...];
        self._reset(mark)
        if (
            (self.expect(r':\{'))
            and
            (self.join())
            and
            (head := self.end_expr())
            and
            (self.expect('\}'))
            and
            (tail := self.string_tail())
        ):
            return [head] + tail;
        self._reset(mark)
        if (
            (self.expect(r':\('))
            and
            (self.join())
            and
            (head := self.hex())
            and
            (self.join())
            and
            (self.expect('\)'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = head , value = chr ( int ( + head , 16 ) ) )] + tail;
        self._reset(mark)
        if (
            (self.expect(r':\['))
            and
            (self.join())
            and
            (head := self.unicode_name())
            and
            (self.join())
            and
            (self.expect('\]'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = head , value = head )] + tail;
        self._reset(mark)
        if (
            (head := self.expect(r'.'))
            and
            (tail := self.string_tail())
        ):
            return [ast . Constant ( token = head , value = + head )] + tail;
        self._reset(mark)
        return None;

    @memoize
    def declare(self) -> Optional[Any]:
        # declare: "I" join "HAS" join "A" join var_name ["ITZ" join end_expr] new_line
        mark = self._mark()
        if (
            (token := self.expect("I"))
            and
            (self.join())
            and
            (self.expect("HAS"))
            and
            (self.join())
            and
            (self.expect("A"))
            and
            (self.join())
            and
            (a := self.var_name())
            and
            (b := self._tmp_15(),)
            and
            (self.new_line())
        ):
            return ast . AnnAssign ( token = token , target = a , value = b [2] if b else ast . Constant ( None , token = token ) , );
        self._reset(mark)
        return None;

    @memoize
    def assign(self) -> Optional[Any]:
        # assign: var_name "R" join end_expr new_line
        mark = self._mark()
        if (
            (a := self.var_name())
            and
            (self.expect("R"))
            and
            (self.join())
            and
            (b := self.end_expr())
            and
            (self.new_line())
        ):
            return ast . Assign ( token = a , targets = [a] , value = b , lineno = 0 , );
        self._reset(mark)
        return None;

    @memoize
    def end_call(self) -> Optional[Any]:
        # end_call: "I" join "IZ" join var_name func_end_arg_list
        mark = self._mark()
        if (
            (token := self.expect("I"))
            and
            (self.join())
            and
            (self.expect("IZ"))
            and
            (self.join())
            and
            (func := self.var_name())
            and
            (args := self.func_end_arg_list())
        ):
            return ast . Call ( token = token , func = func , args = [q for q in args if q is not ...] , keywords = [] , );
        self._reset(mark)
        return None;

    @memoize
    def mid_call(self) -> Optional[Any]:
        # mid_call: "I" join "IZ" join var_name func_mid_arg_list
        mark = self._mark()
        if (
            (token := self.expect("I"))
            and
            (self.join())
            and
            (self.expect("IZ"))
            and
            (self.join())
            and
            (func := self.var_name())
            and
            (args := self.func_mid_arg_list())
        ):
            return ast . Call ( token = token , func = func , args = [q for q in args if q is not ...] , keywords = [] , );
        self._reset(mark)
        return None;

    @memoize
    def func(self) -> Optional[Any]:
        # func: "HOW" join "IZ" join "I" join var_name ["YR" join var_name (("AN" join "YR" join var_name))*] new_line statement* "IF" join "U" join "SAY" join "SO" join new_line
        mark = self._mark()
        if (
            (token := self.expect("HOW"))
            and
            (self.join())
            and
            (self.expect("IZ"))
            and
            (self.join())
            and
            (self.expect("I"))
            and
            (self.join())
            and
            (name := self.var_name())
            and
            (args := self._tmp_16(),)
            and
            (self.new_line())
            and
            (body := self._loop0_17(),)
            and
            (self.expect("IF"))
            and
            (self.join())
            and
            (self.expect("U"))
            and
            (self.join())
            and
            (self.expect("SAY"))
            and
            (self.join())
            and
            (self.expect("SO"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return ast . FunctionDef ( token = token , name = name . id , args = ast . arguments ( token = token , posonlyargs = [] , args = [] if args is None else [ast . arg ( token = token , arg = q [- 1] . id ) for q in [args [: 3]] + args [3]] , kwonlyargs = [] , kw_defaults = [] , defaults = [] , ) , body = [q for q in body if q is not ...] + [ast . Return ( token = token , value = ast . Name ( id = 'IT' ) )] , decorator_list = [] , lineno = 0 , );
        self._reset(mark)
        return None;

    @memoize
    def found(self) -> Optional[Any]:
        # found: "FOUND" join "YR" join end_expr new_line
        mark = self._mark()
        if (
            (token := self.expect("FOUND"))
            and
            (self.join())
            and
            (self.expect("YR"))
            and
            (self.join())
            and
            (value := self.end_expr())
            and
            (self.new_line())
        ):
            return ast . Return ( value = value , token = token );
        self._reset(mark)
        return None;

    @memoize
    def gtfo(self) -> Optional[Any]:
        # gtfo: "GTFO" join new_line
        mark = self._mark()
        if (
            (token := self.expect("GTFO"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return ast . Break ( token = token );
        self._reset(mark)
        return None;

    @memoize
    def branch(self) -> Optional[Any]:
        # branch: "O" join "RLY" join r"\?" join new_line join "YA" join "RLY" join new_line statement* branch_tail
        mark = self._mark()
        if (
            (token := self.expect("O"))
            and
            (self.join())
            and
            (self.expect("RLY"))
            and
            (self.join())
            and
            (self.expect(r"\?"))
            and
            (self.join())
            and
            (self.new_line())
            and
            (self.join())
            and
            (self.expect("YA"))
            and
            (self.join())
            and
            (self.expect("RLY"))
            and
            (self.join())
            and
            (self.new_line())
            and
            (body := self._loop0_18(),)
            and
            (orelse := self.branch_tail())
        ):
            return ast . If ( token = token , test = ast . Name ( id = 'IT' ) , body = [q for q in body if q is not ...] , orelse = [q for q in orelse if q is not ...] , );
        self._reset(mark)
        return None;

    @memoize
    def branch_tail(self) -> Optional[Any]:
        # branch_tail: "MEBBE" join end_expr new_line statement* branch_tail | "NO" join "WAI" join new_line statement* "OIC" join new_line | "OIC" join new_line
        mark = self._mark()
        if (
            (token := self.expect("MEBBE"))
            and
            (self.join())
            and
            (test := self.end_expr())
            and
            (self.new_line())
            and
            (body := self._loop0_19(),)
            and
            (orelse := self.branch_tail())
        ):
            return [ast . If ( token = token , test = test , body = [q for q in body if q is not ...] , orelse = [q for q in orelse if q is not ...] , )];
        self._reset(mark)
        if (
            (self.expect("NO"))
            and
            (self.join())
            and
            (self.expect("WAI"))
            and
            (self.join())
            and
            (self.new_line())
            and
            (body := self._loop0_20(),)
            and
            (self.expect("OIC"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return body + [...];
        self._reset(mark)
        if (
            (self.expect("OIC"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return [...];
        self._reset(mark)
        return None;

    @memoize
    def switch(self) -> Optional[Any]:
        # switch: "WTF" join r"\?" join new_line ((join "OMG" join constant new_line statement*))* [("OMGWTF" join new_line statement*)] "OIC" join new_line
        mark = self._mark()
        if (
            (token := self.expect("WTF"))
            and
            (self.join())
            and
            (self.expect(r"\?"))
            and
            (self.join())
            and
            (self.new_line())
            and
            (cases := self._loop0_21(),)
            and
            (default := self._tmp_22(),)
            and
            (self.expect("OIC"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return ast . Match ( token = token , subject = ast . Name ( token = token , id = 'IT' ) , cases = [ast . match_case ( token = token , pattern = q [3] , body = [w for w in q [5] if w is not ...] , ) for q in cases] + ( [ast . match_case ( token = token , pattern = ast . MatchAs ( ) , body = [q for q in default [3] if q is not ...] , )] if default is not None else [] ) );
        self._reset(mark)
        return None;

    @memoize
    def loop(self) -> Optional[Any]:
        # loop: "IM" join "IN" join "YR" join var_name [un_op_lit "YR" join var_name] [("TIL" | "WILE") join end_expr] new_line statement* "IM" join "OUTTA" join "YR" join var_name new_line
        mark = self._mark()
        if (
            (token := self.expect("IM"))
            and
            (self.join())
            and
            (self.expect("IN"))
            and
            (self.join())
            and
            (self.expect("YR"))
            and
            (self.join())
            and
            (self.var_name())
            and
            (a := self._tmp_23(),)
            and
            (b := self._tmp_24(),)
            and
            (self.new_line())
            and
            (body := self._loop0_25(),)
            and
            (self.expect("IM"))
            and
            (self.join())
            and
            (self.expect("OUTTA"))
            and
            (self.join())
            and
            (self.expect("YR"))
            and
            (self.join())
            and
            (self.var_name())
            and
            (self.new_line())
        ):
            return ast . While ( token = token , test = ast . Constant ( token = token , value = True ) if b is None else b [2] if + b [0] == "WILE" else ast . UnaryOp ( token = token , op = ast . Not ( token = token ) , operand = b [2] ) , body = [q for q in body if q is not ...] + ( [] if a is None else [ast . Assign ( token = a [0] . token , lineno = 0 , targets = [ast . Name ( token = token , id = "IT" )] , value = ast . UnaryOp ( token = a [0] . token , op = a [0] , operand = a [3] ) ) , ast . Nonlocal ( token = a [0] . token , names = [a [3] . id] , )] ) , orelse = [] , );
        self._reset(mark)
        return None;

    @memoize
    def comment(self) -> Optional[Any]:
        # comment: "BTW" r"[^\n]*\n"
        mark = self._mark()
        if (
            (self.expect("BTW"))
            and
            (self.expect(r"[^\n]*\n"))
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def comment_content(self) -> Optional[Any]:
        # comment_content: "OBTW" r".*?(?=TLDR)" "TLDR"
        mark = self._mark()
        if (
            (self.expect("OBTW"))
            and
            (self.expect(r".*?(?=TLDR)"))
            and
            (self.expect("TLDR"))
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def long_comment(self) -> Optional[Any]:
        # long_comment: comment_content new_line
        mark = self._mark()
        if (
            (self.comment_content())
            and
            (self.new_line())
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def begin(self) -> Optional[Any]:
        # begin: "HAI" join float new_line
        mark = self._mark()
        if (
            (self.expect("HAI"))
            and
            (self.join())
            and
            (self.float())
            and
            (self.new_line())
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def end(self) -> Optional[Any]:
        # end: "KTHXBYE" join new_line
        mark = self._mark()
        if (
            (self.expect("KTHXBYE"))
            and
            (self.join())
            and
            (self.new_line())
        ):
            return ...;
        self._reset(mark)
        return None;

    @memoize
    def visible(self) -> Optional[Any]:
        # visible: "VISIBLE" join soft_end_arg_list? "!"?
        mark = self._mark()
        if (
            (token := self.expect("VISIBLE"))
            and
            (self.join())
            and
            (values := self.soft_end_arg_list(),)
            and
            (no_end := self.expect("!"),)
        ):
            return ast . Store ( values = [] if values is None else values , token = token , end = '\n' if no_end is None else '' );
        self._reset(mark)
        return None;

    @memoize
    def gimmeh(self) -> Optional[Any]:
        # gimmeh: "GIMMEH" join var_name
        mark = self._mark()
        if (
            (token := self.expect("GIMMEH"))
            and
            (self.join())
            and
            (value := self.var_name())
        ):
            return ast . Load ( value = value , token = token );
        self._reset(mark)
        return None;

    @memoize
    def cast(self) -> Optional[Any]:
        # cast: var_name "IS" join "NOW" join "A" join type
        mark = self._mark()
        if (
            (left := self.var_name())
            and
            (self.expect("IS"))
            and
            (self.join())
            and
            (self.expect("NOW"))
            and
            (self.join())
            and
            (self.expect("A"))
            and
            (self.join())
            and
            (right := self.type())
        ):
            return ast . Expr ( token = left , value = ast . BinOp ( token = left , left = left , op = ast . LShift ( ) , right = right , ) );
        self._reset(mark)
        return None;

    @memoize
    def make(self) -> Optional[Any]:
        # make: "MAEK" join mid_expr "A" join type
        mark = self._mark()
        if (
            (self.expect("MAEK"))
            and
            (self.join())
            and
            (left := self.mid_expr())
            and
            (self.expect("A"))
            and
            (self.join())
            and
            (right := self.type())
        ):
            return ast . BinOp ( token = left , left = left , op = ast . RShift ( ) , right = right , );
        self._reset(mark)
        return None;

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: void
        mark = self._mark()
        children = []
        while (
            (void := self.void())
        ):
            children.append(void)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: (statement)
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: void
        mark = self._mark()
        children = []
        while (
            (void := self.void())
        ):
            children.append(void)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: join_one
        mark = self._mark()
        children = []
        while (
            (join_one := self.join_one())
        ):
            children.append(join_one)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_5(self) -> Optional[Any]:
        # _loop1_5: join_one
        mark = self._mark()
        children = []
        while (
            (join_one := self.join_one())
        ):
            children.append(join_one)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: "AN" join
        mark = self._mark()
        if (
            (literal := self.expect("AN"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: "MKAY" join
        mark = self._mark()
        if (
            (literal := self.expect("MKAY"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: "MKAY" join
        mark = self._mark()
        if (
            (literal := self.expect("MKAY"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: "MKAY" join
        mark = self._mark()
        if (
            (literal := self.expect("MKAY"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_10(self) -> Optional[Any]:
        # _tmp_10: "MKAY" join
        mark = self._mark()
        if (
            (literal := self.expect("MKAY"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: "AN" join
        mark = self._mark()
        if (
            (literal := self.expect("AN"))
            and
            (join := self.join())
        ):
            return [literal, join];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: r"-?\d+\.\d*" | r"-?\.\d+"
        mark = self._mark()
        if (
            (literal := self.expect(r"-?\d+\.\d*"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect(r"-?\.\d+"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: "WIN" | "FAIL"
        mark = self._mark()
        if (
            (literal := self.expect("WIN"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("FAIL"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: "NOOB" | "TROOF" | "NUMBR" | "NUMBAR" | "YARN" | "TYPE"
        mark = self._mark()
        if (
            (literal := self.expect("NOOB"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("TROOF"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("NUMBR"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("NUMBAR"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("YARN"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("TYPE"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: "ITZ" join end_expr
        mark = self._mark()
        if (
            (literal := self.expect("ITZ"))
            and
            (join := self.join())
            and
            (end_expr := self.end_expr())
        ):
            return [literal, join, end_expr];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: "YR" join var_name (("AN" join "YR" join var_name))*
        mark = self._mark()
        if (
            (literal := self.expect("YR"))
            and
            (join := self.join())
            and
            (var_name := self.var_name())
            and
            (_loop0_26 := self._loop0_26(),)
        ):
            return [literal, join, var_name, _loop0_26];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_17(self) -> Optional[Any]:
        # _loop0_17: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_18(self) -> Optional[Any]:
        # _loop0_18: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_19(self) -> Optional[Any]:
        # _loop0_19: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_20(self) -> Optional[Any]:
        # _loop0_20: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_21(self) -> Optional[Any]:
        # _loop0_21: (join "OMG" join constant new_line statement*)
        mark = self._mark()
        children = []
        while (
            (_tmp_27 := self._tmp_27())
        ):
            children.append(_tmp_27)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_22(self) -> Optional[Any]:
        # _tmp_22: "OMGWTF" join new_line statement*
        mark = self._mark()
        if (
            (literal := self.expect("OMGWTF"))
            and
            (join := self.join())
            and
            (new_line := self.new_line())
            and
            (_loop0_28 := self._loop0_28(),)
        ):
            return [literal, join, new_line, _loop0_28];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_23(self) -> Optional[Any]:
        # _tmp_23: un_op_lit "YR" join var_name
        mark = self._mark()
        if (
            (un_op_lit := self.un_op_lit())
            and
            (literal := self.expect("YR"))
            and
            (join := self.join())
            and
            (var_name := self.var_name())
        ):
            return [un_op_lit, literal, join, var_name];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_24(self) -> Optional[Any]:
        # _tmp_24: ("TIL" | "WILE") join end_expr
        mark = self._mark()
        if (
            (_tmp_29 := self._tmp_29())
            and
            (join := self.join())
            and
            (end_expr := self.end_expr())
        ):
            return [_tmp_29, join, end_expr];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_25(self) -> Optional[Any]:
        # _loop0_25: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_26(self) -> Optional[Any]:
        # _loop0_26: ("AN" join "YR" join var_name)
        mark = self._mark()
        children = []
        while (
            (_tmp_30 := self._tmp_30())
        ):
            children.append(_tmp_30)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_27(self) -> Optional[Any]:
        # _tmp_27: join "OMG" join constant new_line statement*
        mark = self._mark()
        if (
            (join := self.join())
            and
            (literal := self.expect("OMG"))
            and
            (join_1 := self.join())
            and
            (constant := self.constant())
            and
            (new_line := self.new_line())
            and
            (_loop0_31 := self._loop0_31(),)
        ):
            return [join, literal, join_1, constant, new_line, _loop0_31];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_28(self) -> Optional[Any]:
        # _loop0_28: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_29(self) -> Optional[Any]:
        # _tmp_29: "TIL" | "WILE"
        mark = self._mark()
        if (
            (literal := self.expect("TIL"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("WILE"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_30(self) -> Optional[Any]:
        # _tmp_30: "AN" join "YR" join var_name
        mark = self._mark()
        if (
            (literal := self.expect("AN"))
            and
            (join := self.join())
            and
            (literal_1 := self.expect("YR"))
            and
            (join_1 := self.join())
            and
            (var_name := self.var_name())
        ):
            return [literal, join, literal_1, join_1, var_name];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_31(self) -> Optional[Any]:
        # _loop0_31: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children;

    KEYWORDS = ()
    SOFT_KEYWORDS = ('A', 'ALL', 'AN', 'ANY', 'BIGGR', 'BOTH', 'BTW', 'DIFF', 'DIFFRINT', 'EITHER', 'FAIL', 'FOUND', 'GIMMEH', 'GTFO', 'HAI', 'HAS', 'HOW', 'I', 'IF', 'IM', 'IN', 'IS', 'ITZ', 'IZ', 'KTHXBYE', 'MAEK', 'MEBBE', 'MKAY', 'MOD', 'NERFIN', 'NO', 'NOOB', 'NOW', 'NUMBAR', 'NUMBR', 'O', 'OBTW', 'OF', 'OIC', 'OMG', 'OMGWTF', 'OUTTA', 'PRODUKT', 'QUOSHUNT', 'R', 'RLY', 'SAEM', 'SAY', 'SMALLR', 'SMOOSH', 'SO', 'SUM', 'TIL', 'TLDR', 'TROOF', 'TYPE', 'U', 'UPPIN', 'VISIBLE', 'WAI', 'WILE', 'WIN', 'WON', 'WTF', 'YA', 'YARN', 'YR')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
